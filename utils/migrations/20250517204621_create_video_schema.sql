-- +goose Up

CREATE SCHEMA IF NOT EXISTS video;

create table video.series
(
    series_id   integer generated by default as identity
        primary key,
    lft         integer                                           not null,
    rgt         integer                                           not null,
    name        text                                              not null,
    in_url      boolean                  default true             not null,
    url         text                                              not null,
    description text                     default ''::text         not null,
    thumbnail   text                     default ''::text         not null,
    tags        text[]                   default ARRAY []::text[] not null,
    status      text                     default 'internal'::text not null
        constraint status_chk
            check (status = ANY (ARRAY ['private'::text, 'internal'::text, 'public'::text])),
    created_at  timestamp with time zone default now()            not null,
    created_by  integer
                                                                  references people.users
                                                                      on update cascade on delete set null,
    updated_at  timestamp with time zone,
    updated_by  integer
                                                                  references people.users
                                                                      on update cascade on delete set null,
    deleted_at  timestamp with time zone,
    deleted_by  integer
                                                                  references people.users
                                                                      on update cascade on delete set null,
    constraint created_chk
        check ((created_at <= updated_at) AND (created_at <= deleted_at)),
    constraint deleted_chk
        check ((deleted_at >= created_at) AND (deleted_at >= updated_at)),
    constraint updated_chk
        check ((updated_at >= created_at) AND (updated_at <= deleted_at))
);

create table video.encode_presets
(
    preset_id   integer generated by default as identity
        primary key,
    name        text                  not null,
    description text default ''::text not null
);

create table video.encode_formats
(
    format_id   integer generated by default as identity
        primary key,
    name        text                  not null,
    description text default ''::text not null,
    mime_type   text                  not null,
    mode        text                  not null,
    width       integer               not null,
    height      integer               not null,
    arguments   text                  not null,
    file_suffix text                  not null,
    watermarked boolean               not null
);

comment on column video.encode_formats.file_suffix is 'When a video has been created by this format, it will be stored with the existing
filename + the file_suffix. If there is no file_suffix is will use the format ID';

create table video.encode_preset_formats
(
    preset_id integer not null
        references video.encode_presets
            on update cascade on delete cascade,
    format_id integer not null
        references video.encode_formats
            on update cascade on delete cascade,
    constraint presets_encode_formats_pkey
        primary key (preset_id, format_id)
);

create table video.items
(
    video_id        integer generated by default as identity
        primary key,
    series_id       integer                                           not null
        references video.series
            on update cascade on delete cascade,
    name            text                                              not null,
    url             text                                              not null,
    description     text                     default ''::text         not null,
    thumbnail       text                     default ''::text         not null,
    duration        integer                  default 0                not null,
    views           integer                  default 0                not null,
    genre           integer                  default 0                not null,
    tags            text[]                   default ARRAY []::text[] not null,
    series_position smallint,
    status          text                     default 'internal'::text not null
        constraint status_chk
            check (status = ANY (ARRAY ['processing'::text, 'private'::text, 'internal'::text, 'public'::text])),
    preset_id       integer
                                                                      references video.encode_presets
                                                                          on update cascade on delete set null,
    broadcast_date  timestamp with time zone default now()            not null,
    created_at      timestamp with time zone default now()            not null,
    created_by      integer
                                                                      references people.users
                                                                          on update cascade on delete set null,
    updated_at      timestamp with time zone,
    updated_by      integer
                                                                      references people.users
                                                                          on update cascade on delete set null,
    deleted_at      timestamp with time zone,
    deleted_by      integer
                                                                      references people.users
                                                                          on update cascade on delete set null,
    constraint created_chk
        check ((created_at <= updated_at) AND (created_at <= deleted_at)),
    constraint deleted_chk
        check ((deleted_at >= created_at) AND (deleted_at >= updated_at)),
    constraint updated_chk
        check ((updated_at >= created_at) AND (updated_at <= deleted_at))
);

comment on column video.items.duration is 'Seconds is accurate enough for VOD. Playout software should probe
the file and store it''s own time, maybe in ms?';

create table video.playlists
(
    playlist_id integer generated by default as identity
        primary key,
    name        text                                              not null,
    description text                     default ''::text         not null,
    thumbnail   text                     default ''::text         not null,
    status      text                     default 'internal'::text not null,
    created_at  timestamp with time zone default now()            not null,
    created_by  integer
                                                                  references people.users
                                                                      on update cascade on delete set null,
    updated_at  timestamp with time zone,
    updated_by  integer
                                                                  references people.users
                                                                      on update cascade on delete set null,
    deleted_at  timestamp with time zone,
    deleted_by  integer
                                                                  references people.users
                                                                      on update cascade on delete set null
);

create table video.playlist_items
(
    playlist_id   integer not null
        references video.playlists
            on update cascade on delete cascade,
    video_item_id integer not null
        references video.items
            on update cascade on delete cascade,
    position      smallint,
    primary key (playlist_id, video_item_id)
);

create table video.files
(
    file_id   integer generated by default as identity
        primary key,
    video_id  integer               not null
        references video.items
            on update cascade on delete cascade,
    format_id integer               not null
        references video.encode_formats
            on update cascade on delete restrict,
    uri       text                  not null,
    status    text                  not null
        constraint status_chk
            check (status = ANY (ARRAY ['processing'::text, 'private'::text, 'internal'::text, 'public'::text])),
    size      bigint  default 0     not null,
    is_source boolean default false not null
);

comment on table video.files is 'Supporting video files for a video item';

comment on column video.files.status is 'Indicates status of the file i.e. public, internal, error';

comment on column video.files.size is 'Measured in kilobytes (KB)';

comment on column video.files.is_source is 'When we attempt to create a VOD of a video, this file would be used as the source';

create table video.hits
(
    hit_id      integer generated by default as identity
        primary key,
    start_time  timestamp with time zone not null,
    mode        text                     not null
        constraint modechk
            check (mode = ANY (ARRAY ['watch'::text, 'download'::text, 'embed'::text])),
    ip_address  inet                     not null,
    client_info text                     not null,
    percent     integer                  not null,
    video_id    integer                  not null
        references video.items
            on update cascade on delete cascade
);

create index starttime
    on video.hits (start_time);

create view series_paths(series_id, path, status) as
SELECT node.series_id,
       array_to_string(array_agg(parent.url ORDER BY parent.lft), '/'::text) AS path,
       node.status
FROM video.series node,
     video.series parent
WHERE node.lft >= parent.lft
  AND node.lft <= parent.rgt
  AND parent.in_url
GROUP BY node.series_id
ORDER BY node.lft;

-- +goose Down

DROP SCHEMA video CASCADE;